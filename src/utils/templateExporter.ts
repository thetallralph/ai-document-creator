import { getTemplateSource } from '../documents/sourceImports';
import { SerializedDocument } from '../types/template';
import { serializeDocument } from './templateSerializer';

/**
 * Exports a template in a format compatible with the Babel compiler
 */
export function exportTemplateForBabel(templateName: string, component?: React.FC): string | null {
  // First, try to get the original source
  const originalSource = getTemplateSource(templateName);
  
  if (originalSource) {
    // Transform the original source to match our expected format
    return transformSourceForExport(originalSource);
  }
  
  // For dynamic templates, generate source from the component
  if (component) {
    const serialized = serializeDocument(component);
    if (serialized) {
      return generateTemplateFromSerialized(serialized);
    }
  }
  
  return null;
}

/**
 * Generate template source from serialized document
 */
function generateTemplateFromSerialized(doc: SerializedDocument): string {
  const pages = doc.pages.map(page => {
    const props = [];
    if (page.background) props.push(`background="${page.background}"`);
    if (page.padding) {
      if (typeof page.padding === 'string') {
        props.push(`padding="${page.padding}"`);
      } else {
        props.push(`padding={${page.padding}}`);
      }
    }
    
    // For now, we'll render the content as a simple div
    // In a more complete implementation, we'd reconstruct the full element tree
    const content = page.elements.length > 0 
      ? `\n        <div style={{ width: '100%', height: '100%' }}>\n          {/* Page content */}\n        </div>\n      `
      : '';
    
    return `      <Page ${props.join(' ')}>${content}</Page>`;
  }).join('\n');

  return `// Generated by AI Document Creator
// This template can be imported back into the application

const Template = () => {
  return (
    <Document title="${doc.title}" type="${doc.type}" paperSize="${doc.paperSize}">
${pages}
    </Document>
  );
};`;
}

/**
 * Transform source code to ensure it's compatible with our import system
 */
function transformSourceForExport(source: string): string {
  // Extract imported variables and their files
  const importRegex = /import\s+{([^}]+)}\s+from\s+['"](.\/[^'"]+)['"]/g;
  const imports: Array<{ vars: string[], path: string }> = [];
  let match;
  
  while ((match = importRegex.exec(source)) !== null) {
    const vars = match[1].split(',').map(v => v.trim());
    const path = match[2];
    if (!path.includes('components/document-components')) {
      imports.push({ vars, path });
    }
  }
  
  // Remove all import statements
  let transformed = source.replace(/import\s+.*?from\s+['"].*?['"];?\s*/g, '');
  
  // Inline any imported styles or constants
  for (const imp of imports) {
    if (imp.path.includes('styles')) {
      // For styles imports, we need to inline the styles
      for (const varName of imp.vars) {
        if (varName === 'cactuceStyles') {
          transformed = inlineCactuceStyles() + '\n\n' + transformed;
        } else if (varName === 'outletCatalogStyles') {
          transformed = inlineOutletCatalogStyles() + '\n\n' + transformed;
        } else if (varName === 'outletFlyerStyles') {
          transformed = inlineOutletFlyerStyles() + '\n\n' + transformed;
        } else if (varName === 'outletPresentationStyles') {
          transformed = inlineOutletPresentationStyles() + '\n\n' + transformed;
        }
        // For any other style imports, we'll try to inline them as empty objects
        else if (!transformed.includes(`const ${varName}`)) {
          transformed = `const ${varName} = {};\n\n` + transformed;
        }
      }
    }
  }
  
  // Ensure the component is named "Template" for consistency
  transformed = transformed.replace(
    /export\s+const\s+(\w+)\s*:\s*React\.FC\s*=/g,
    'const Template ='
  );
  transformed = transformed.replace(
    /export\s+const\s+(\w+)\s*=/g,
    'const Template ='
  );
  
  // Remove any remaining export statements
  transformed = transformed.replace(/export\s+/g, '');
  
  // Add a comment header
  const header = `// Generated by AI Document Creator
// This template can be imported back into the application
// Edit as needed and ensure it follows the template structure

`;
  
  return header + transformed.trim();
}

/**
 * Inline the cactuce styles to avoid import issues
 */
function inlineCactuceStyles(): string {
  return `const cactuceStyles = {
  colors: {
    green: '#2ECC71',
    blue: '#3498DB',
    orange: '#E67E22',
    darkGray: '#2C3E50',
    lightGray: '#95A5A6',
    lightGreen: '#E8F8F5',
    lightBlue: '#EBF5FB',
    lightOrange: '#FDF2E9',
    textPrimary: '#000000',
    textSecondary: '#000000',
    textLight: '#333333'
  },
  fonts: {
    primary: '"Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
    heading: '"Playfair Display", Georgia, serif',
    mono: '"Space Mono", monospace'
  },
  fontWeights: {
    regular: 400,
    medium: 500,
    semibold: 600,
    bold: 700,
    extrabold: 800,
    black: 900
  },
  spacing: {
    xs: 5,
    sm: 10,
    md: 15,
    lg: 20,
    xl: 30,
    xxl: 40
  },
  borderRadius: {
    small: 4,
    medium: 8,
    large: 12,
    round: '50%'
  },
  shadows: {
    small: '0 2px 4px rgba(0,0,0,0.1)',
    medium: '0 4px 8px rgba(0,0,0,0.1)',
    large: '0 8px 16px rgba(0,0,0,0.1)'
  }
};`;
}

/**
 * Inline the outlet catalog styles
 */
function inlineOutletCatalogStyles(): string {
  return `const outletCatalogStyles = {
  colors: {
    primary: '#1a1a1a',
    secondary: '#333333',
    accent: '#e74c3c',
    background: '#ffffff',
    text: {
      primary: '#1a1a1a',
      secondary: '#333333',
      light: '#555555'
    },
    surface: {
      primary: '#e8e8e8',
      secondary: '#f5f5f5'
    }
  },
  typography: {
    fontFamilies: {
      heading: 'Georgia, serif',
      body: 'system-ui, -apple-system, sans-serif'
    },
    sizes: {
      h1: 48,
      h2: 28,
      h3: 18,
      h4: 15,
      large: 18,
      regular: 14,
      small: 12,
      caption: 11
    }
  },
  spacing: {
    xs: 3,
    sm: 5,
    md: 10,
    lg: 15,
    xl: 25,
    xxl: 30
  }
};`;
}

/**
 * Inline outlet flyer styles (placeholder)
 */
function inlineOutletFlyerStyles(): string {
  return `const outletFlyerStyles = {};`;
}

/**
 * Inline outlet presentation styles (placeholder)
 */
function inlineOutletPresentationStyles(): string {
  return `const outletPresentationStyles = {};`;
}

/**
 * Create a template from scratch (for dynamic templates)
 */
export function createTemplateSource(
  title: string,
  type: 'flyer' | 'booklet' | 'presentation',
  paperSize: string,
  pages: Array<{ background?: string; padding?: string; content: string }>
): string {
  const pagesCode = pages.map((page, index) => {
    const props = [];
    if (page.background) props.push(`background="${page.background}"`);
    if (page.padding) props.push(`padding="${page.padding}"`);
    
    return `      <Page ${props.join(' ')}>
        ${page.content}
      </Page>`;
  }).join('\n');

  return `// Generated by AI Document Creator
// This template can be imported back into the application

const Template = () => {
  return (
    <Document title="${title}" type="${type}" paperSize="${paperSize}">
${pagesCode}
    </Document>
  );
};`;
}